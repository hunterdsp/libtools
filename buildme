#!/usr/bin/env bash
#
# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "cffi>=2.0.0",
#     "libtools",
#     "llvmlite>=0.46.0",
# ]
#
# [tool.uv.sources]
# libtools = { path = "." }
# ///

# ############################################################################
# EXECUTABLE: buildme             			                                 #
# PACKAGE: libtools version 0.1.0	                                         #
# ############################################################################
set -euo pipefail
IFS=$'\n\t'
# RELIABLY get the absoulute path to this file
LIBTOOLS_ROOT="$(
	# Assume we are running under -u so initialize any referenced variables
    # Output path to the calling script's location
    cd -- "$(dirname -- "${BASH_SOURCE[0]}")" >/dev/null 2>&1 || exit
    pwd -P
)"

##############################################################################
# Use the above in all your scripts to make them more robust and reliable.   #
# See http://redsymbol.net/articles/unofficial-bash-strict-mode/ for more.	 #
##############################################################################
# -e:           Immediately exit if any command has non-zero exit status.    #
# -u:           Reference to variables not previously defined is an error.   #
# -o pipefail:  Take pipeline exit status from first to fail.                #
# IFS=$'\n\t':  Word splitting on newline and tab only (default $' \n\t').   #
#----------------------------------------------------------------------------#
# -x:           When debugging, traces execution and prints to stdout.       #
##############################################################################

# Use exit traps which ALWAYS run just before the script exits.
finish() {
	echo "Cleaning up!!!"
	# rm -rf "${LIBTOOLS_BUILDPATH:-'./build'}"
}
trap finish EXIT

# Initialize all referenced variables
OPTARG=
OPTIND=0
LIBTOOLS_TYPE=

# Using 'heredoc' for help can make formatting simpler. Appending '-' to
# '<<' strips leading tabs (and only tabs - no spaces) from each line; leaving
# it off  leaves indentation as is. The || true is needed with set -e because
# as expected read exits with nonzero exit code. cat would be an alternative.
read -r -d '' HELP <<-'EOF' || true
	Usage: buildme [OPTIONS] [-p PARAM] [ARGS] ...

	  Build Example Libraries and Other Executable Machine Code.

	Options:
	  -h         Show this message and exit.
	  -t TYPE    What type of artifact would you like to build?
	  -v         Show the version and exit.

EOF

# Specify options. Add ':' to start and after options that take arguments.
while getopts ":ht:v" option; do

	# Parse options.
	case $option in

	# h for help.
	h)
		echo "${HELP}"
		exit 0
		;;

	# Unrecognized options set $option to '?'.
	\?)
		echo "Invalid option: -${OPTARG}"
		echo "${HELP}"
		exit 0
		;;

	# Option taking a parameter stored for later processing.
	t)
		LIBTOOLS_TYPE="${OPTARG}"
		;;

	# Option processed immediately
	v)
		# shellcheck disable=SC2005
		echo "$(uv version)"
		exit 0
		;;

	esac

done

# Remove options from the input list $@ so the first remaining argument is $1.
shift "$((OPTIND - 1))"
MYAPP="myapp"
MYLIB="mylib"
SRC="${LIBTOOLS_ROOT}/src"
BLD="${LIBTOOLS_ROOT}/build"
BIN="${BLD}/bin" 
LIB="${BLD}/lib"
LIBTOOLS_VERSION=$(uv version --short)
mkdir -p "${BIN}"
mkdir -p "${LIB}"

# Process option -p where PARAM could be a command, filename, etc...
if [ -n "${LIBTOOLS_TYPE}" ]; then

	# Parse options.
	case $LIBTOOLS_TYPE in

	EXE)

		# Create executable
		echo "Building executable!"
		echo "Run the complete toolchain: ${MYAPP}"
		gcc -Iinc "${SRC}/${MYAPP}.c" "${LIB}/${MYLIB}.o" -o "${BIN}/${MYAPP}"

		echo "Running Application: $("${BIN}/${MYAPP}")"
		exit 0
		;;

	LLVM)

		# Create executable
		LLVMPATH="${LIBTOOLS_ROOT}/src/${MYAPP}_llvm.c"
		LLVMLIBPATH="${LIBTOOLS_BUILDPATH}/${MYLIB}_llvm.o"
		LLVMBINPATH="${LIBTOOLS_ROOT}/src/${MYAPP}_llvm"
		CREATELLVMLIB="${LIBTOOLS_ROOT}/src/libtools/${MYLIB}_llvm.py"
		echo "Building C executable using llvmlite-Python-to-ELF-object!"
		echo "Run the complete toolchain: ./${MYAPP}_llvm"
		uv run python "${CREATELLVMLIB}"
		gcc -Iinc "${LLVMPATH}" "${LLVMLIBPATH}" -o "${LLVMBINPATH}"
		echo "Running Application: $(${LLVMBINPATH})"
		exit 0
		;;

	STATIC)

		# Create executable
		echo "Building static library!"
		gcc -Iinc -Wall -g -c -o "${LIB}/${MYLIB}.o" "${SRC}/${MYLIB}.c"
		ar rcs "${LIB}/${MYLIB}.a" "${LIB}/${MYLIB}.o" 

		echo "Building application & linking in library!"
		gcc -Iinc -Wall -g -c "${SRC}/${MYAPP}.c" -o "${LIB}/${MYAPP}.o"
		gcc -Iinc -g -o "${BIN}/${MYAPP}" "${LIB}/${MYAPP}.o" "${LIB}/${MYLIB}.a"

		echo "Running the application: $("${BIN}/${MYAPP}")"

		;;

	SHARED)

		# Create executable
		OBJPATH="${LIB}/${MYLIB}.o"
		SONAME="${MYLIB}.so.${LIBTOOLS_VERSION:0:1}"
		SOPATH="${LIB}/${SONAME}"
		REALNAME="${MYLIB}.so.${LIBTOOLS_VERSION:0:3}"
		REALPATH="${LIB}/${REALNAME}"
		echo "Building shared library!"
		gcc -fpic -Iinc -Wall -g -c "${SRC}/${MYLIB}.c" -o "${OBJPATH}"
		gcc -g -shared -Wl,-soname,"${SONAME}" -o "${REALNAME}" "${OBJPATH}"
		
		# Create links
		ln -sf "${SOPATH}" "${REALPATH}" 
		/sbin/ldconfig -n "${LIB}"
		mv "${REALNAME}" "${REALPATH}"

		echo "Building application!"
		gcc -Iinc -Wall -g -c "${SRC}/${MYAPP}.c" -o "${LIB}/${MYAPP}.o"
		gcc -Iinc -g -o "${BIN}/${MYAPP}" "${LIB}/${MYAPP}.o" "${OBJPATH}"

		echo "Running the application: $(LD_LIBRARY_PATH="." "${BIN}/${MYAPP}")"
		echo ""
		echo "*** HERE IS THE OUTPUT OF readelf IF YOU HAVE binutils ***"
		echo ""
		readelf --all "${REALPATH}" || true
		;;

	DYNAMIC)

		echo "Building application with dynamically loaded library!"
		if [[ ! -f "${BIN}/${MYAPP}_dyn" ]] ; then
			meson setup "${BLD}"
			meson compile -C "${BLD}"
		fi
		gcc -Wall -g -c "${SRC}/${MYAPP}_dyn.c" -o "${LIB}/${MYAPP}_dyn.o"
		gcc -g -o "${BIN}/${MYAPP}_dyn" "${LIB}/${MYAPP}_dyn.o" -ldl
		cd "${BLD}"
		echo "Running the application: $(LD_LIBRARY_PATH="." \
			"${BIN}/${MYAPP}_dyn")"

		;;

	PYTHON)

		uv run python-cxx-example
		;;
	
	CFFI)

		CREATELIB="${SRC}/libtools/${MYLIB}_cffi.py"
		echo "Compiling C code into a Python module & calling function gives:"
		uv run python "${CREATELIB}" && 
		  uv run --directory "${LIB}" python -c \
		    "import ${MYLIB}_cffi.lib as l; print(l.pi_approx(10))" &&
		    rm "${LIBTOOLS_ROOT}/${MYLIB}_cffi".{c,o}
		
		;;

	CFFI-CALLBACK)

		CB=mycallback_cffi.py
		CREATECB="${SRC}/libtools/${CB}"
		echo "Compiling C code with embedded Python & calling function gives:"
		uv run python "${CREATECB}" --directory "${BIN}" 

		;;

	NUMBA)

		CREATELIB="${LIBTOOLS_ROOT}/src/libtools/create_mylib_numba.py"
		echo "Calling JIT code from Python compiled extension gives:"
		uv run python "${CREATELIB}" 
		
		;;

	NUMBA-CALLBACK)

		CREATENUMBACB="${LIBTOOLS_ROOT}/src/libtools/mycallback_numba.py"
		echo "Calling JIT code from compiled extension gives:"
		uv run python "${CREATENUMBACB}" --directory "${BIN}" 

		;;

	# Unrecognized options set $option to '?'.
	\?)
	
		echo "Invalid option: -${OPTARG}"
		echo "${HELP}"
		exit 0
		;;

	esac

	fi
